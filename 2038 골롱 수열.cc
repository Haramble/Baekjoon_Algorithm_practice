#include <cstdio>
/*
골롱 수열은 모든 k에 대해 k가 수열상에서 f(k)번 등장하는 단조증가 수열이다.
단조증가 수열은 k값이 증가함에 따라 f(k)값이 감소하지 않는 수열을 말한다.
여기서 k와 f(k)는 모두 자연수이다.

위 정의를 잘 생각해보면
만약 f(k) = x라면 --> x라는 숫자가 f(k)에서 x번 나타난다는 뜻이다.
이 수열을 나타내기 위해서는 초기값이 필요할것 같아서 구글링을 해 보니 점화식을 찾을 수 있었다.
f(1) = 1
f(n+1) = 1 + f(n + 1 - f(f(n)))

위의 점화식에서 초기값이 f(1) = 1이라는 것을 알게 되었고, 밑에 점화식은 사실 잘 이해가 가지 않았다.
그래서 그냥 내가 이해한 대로 1이 다 나왔고 단조 증가수열이니까 다음은 2가 나와야한다고 생각했다.
따라서 f(2) = 2 라고 놓으면, 골롱 수열의 정의에 의해 2가 f수열에서 2번나와야 하므로 f(3) = 2 가 된다.
그리고 f(3) = 2 이므로 3이 2번 나와야 하므로 f(4),f(5) = 3 이 되고,
f(4) = 3 이므로 f(6),f(7),f(8) = 4가 된다.
이런식으로 생각하면 일반항을 구할 수 있다.

그리고 N의 범위가 20억이므로 앞에서부터 수열을 구하는 방법은 시간초과에 걸린다.
그래서 골롱 수열의 합을 같이 구해야 한다.
만약 골롱 수열의 합이 N보다 커지면 f(N)의 값은 골롱 수열의 합이 커지는 순간의 지점이 된다.
즉 다시말해서 만약 f(N) <= sum(f(1) ~ f(i)) 이면 f(N) = i 이다. 
*/
long long N, sum;
int p=1, F[673366]; //배열의 범위가 673366인 이유는 N이 20억일때 값을 구해보니 673365라서 최대값이 어차피 673365를 넘지 않기 때문에 정했다.

int main(){
	scanf("%lld",&N);

	for(int q=1; q<=N; q++){
		if(p == F[q-F[p]]) p++;
		F[q] = p;
		sum += F[q];
		if(sum>=N){
			printf("%d",q);
			break;
		}
	}

	return 0;
}
