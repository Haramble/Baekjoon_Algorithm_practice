#include<cstdio>
/*
이 문제는 마지막 집에 칠한 색을 기준으로 그때까지의 최소 가격을 R, G, B로 선언해 놓고 R, G, B중 최소값을 출력하면 된다.
(자세히 설명하면 : 마지막 집에 red를 칠했을 경우의 최소 가격을 R, 마지막 집에 green을 칠했을 경우의
최소 가격을 G, 마지막 집에 blue를 칠햇을 경우의 최소 가격을 B라고 한다.)

처음에 아무것도 칠하지 않았을 때의 R, G, B를 0으로 초기화 시켜놓고
rgb를 하나 입력 받을 때 마다 R, G, B를 업데이트 시켜준다.

예를들어서 rgb 입력이 들어왔고, 그 중에 r을 택해서 칠한다고 가정하면
문제 조건에서 이웃한 집은 같은 색을 칠할 수 없으므로 이전 집은 green 혹은 blue로 칠해져 있어야 한다.
따라서 좀 전에 (R, G, B)의 정의를 "마지막 집에 (R, G, B)를 칠했을 때의 최소가격"이라고 했으므로
G와 B중에서 작은것을 택하여 r과 더한것이 R이 된다.

식으로 나타내면 R,G,B가 다음과 같이 나타낼 수 있다.
R = (G와 B 중에 작은 것) + (현재 입력받은 r의 값)
G = (R과 B 중에 작은 것) + (현재 입력받은 g의 값)
B = (R가 G 중에 작은 것) + (현재 입력받은 b의 값)

이것을 N번째 집까지 반복한 후에 R, G, B중에서 가장 작은값을 출력하면 된다.
*/
int N,R,G,B,r,g,b;
int main(){
    scanf("%d",&N);
    while(N--){
        int t1 = R, t2 = G, t3 = B; //RGB를 임시적으로 저장해 놓는 이유는 그냥 RGB를 쓰게 되면 30,31번째 줄에서 update된 R이 쓰이므로 G와 B의 값이 이상해진다.
        scanf("%d %d %d",&r,&g,&b); //rgb를 입력받음

        R = t2 > t3 ? t3+r : t2+r; //위의 식을 코드로 옮긴것
        G = t1 > t3 ? t3+g : t1+g;
        B = t1 > t2 ? t2+b : t1+b;
    }
    printf("%d",R>G ? (G>B ? B : G) : (R>B ? B : R)); //RGB중 최소값 출력
    return 0;
}
